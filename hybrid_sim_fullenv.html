\
    <!doctype html>
    <html>
    <head>
      <meta charset="utf-8"/>
      <title>Hybrid EV-Sub Simulator — Currents, Waves & Speed PID</title>
      <style>
        body { font-family: Arial, Helvetica, sans-serif; margin: 0; display: flex; height:100vh; }
        #left { width:68%; background:#111; color:#fff; display:flex; flex-direction:column; }
        #canvas { flex:1; background: linear-gradient(#79c1ff,#a6e0ff); }
        #right { width:32%; padding:10px; box-sizing:border-box; background:#f5f5f5; overflow:auto; }
        .panel { margin-bottom:12px; padding:8px; background:#fff; border-radius:6px; box-shadow:0 2px 6px rgba(0,0,0,0.08); }
        label { display:block; font-size:13px; color:#333; margin-bottom:6px; }
        input[type=range] { width:100%; }
        input[type=number]{ width:100%; box-sizing:border-box; padding:6px; margin-bottom:6px; }
        button { padding:8px 12px; margin-top:6px; cursor:pointer; }
        pre { font-size:12px; background:#eee; padding:8px; border-radius:6px; max-height:220px; overflow:auto;}
        .row { display:flex; gap:8px; }
        .col { flex:1; }
        .small { font-size:12px; color:#666; }
      </style>
    </head>
    <body>
      <div id="left">
        <canvas id="c" class="canvas" width="1280" height="820" style="display:block"></canvas>
      </div>
      <div id="right">
        <div class="panel">
          <h3>Manual Controls</h3>
          <label>Throttle: <span id="thVal">0</span></label>
          <input id="th" type="range" min="-1" max="1" step="0.01" value="0">
          <label>Steer (rad): <span id="stVal">0</span></label>
          <input id="st" type="range" min="-1.2" max="1.2" step="0.01" value="0">
          <label>Ballast (dive/surface): <span id="ballVal">0</span></label>
          <input id="ball" type="range" min="-1" max="1" step="0.01" value="0">
          <button id="reset">Reset</button>
        </div>

        <div class="panel">
          <h3>Autopilot</h3>
          <div class="row">
            <div class="col">
              <label>Mode</label>
              <select id="mode">
                <option value="off">Off (manual)</option>
                <option value="depth">Depth PID</option>
                <option value="heading">Heading PID</option>
                <option value="speed">Speed PID</option>
                <option value="both">Depth + Heading</option>
                <option value="all">Depth + Heading + Speed</option>
              </select>
            </div>
            <div class="col">
              <label>Engage</label>
              <button id="engage">Engage</button>
            </div>
          </div>

          <label>Target Depth (m): <span id="targetDepthVal">20</span></label>
          <input id="targetDepth" type="range" min="0" max="400" step="1" value="20">

          <label>Target Heading (deg): <span id="targetHeadingVal">0</span></label>
          <input id="targetHeading" type="range" min="-180" max="180" step="1" value="0">

          <label>Target Speed (m/s): <span id="targetSpeedVal">3.0</span></label>
          <input id="targetSpeed" type="range" min="0" max="10" step="0.1" value="3.0">

          <hr>
          <h4 class="small">Depth PID</h4>
          <label>Kp <input id="kp_d" type="number" step="0.01" value="0.8"></label>
          <label>Ki <input id="ki_d" type="number" step="0.001" value="0.01"></label>
          <label>Kd <input id="kd_d" type="number" step="0.01" value="0.3"></label>

          <h4 class="small">Heading PID</h4>
          <label>Kp <input id="kp_h" type="number" step="0.01" value="1.5"></label>
          <label>Ki <input id="ki_h" type="number" step="0.001" value="0.002"></label>
          <label>Kd <input id="kd_h" type="number" step="0.01" value="0.2"></label>

          <h4 class="small">Speed (surge) PID</h4>
          <label>Kp <input id="kp_s" type="number" step="0.01" value="0.6"></label>
          <label>Ki <input id="ki_s" type="number" step="0.001" value="0.01"></label>
          <label>Kd <input id="kd_s" type="number" step="0.01" value="0.05"></label>
        </div>

        <div class="panel">
          <h3>Environment</h3>
          <label>Current Speed (m/s): <span id="currSpVal">0.5</span></label>
          <input id="currSp" type="range" min="0" max="5" step="0.1" value="0.5">
          <label>Current Dir (deg): <span id="currDirVal">90</span></label>
          <input id="currDir" type="range" min="0" max="360" step="1" value="90">
          <hr>
          <label>Wave Amplitude (m): <span id="waveAmpVal">6</span></label>
          <input id="waveAmp" type="range" min="0" max="50" step="1" value="6">
          <label>Wave Frequency (Hz): <span id="waveFreqVal">0.2</span></label>
          <input id="waveFreq" type="range" min="0" max="1" step="0.01" value="0.2">
          <small class="small">Wave & current affect the sea surface and vehicle forces.</small>
        </div>

        <div class="panel">
          <h3>Telemetry</h3>
          <pre id="tele"></pre>
        </div>

        <div class="panel">
          <h3>Parameters</h3>
          <label>Mass (kg)</label><input id="mass" type="number" value="800">
          <label>Hull volume (m³)</label><input id="volume" type="number" value="0.9">
          <label>Water density (kg/m³)</label><input id="rho" type="number" value="1025">
          <label>Drag coeff (Cd)</label><input id="cd" type="number" value="0.8">
          <button id="applyParams">Apply</button>
        </div>

        <div class="panel">
          <h3>Logging</h3>
          <div class="row">
            <button id="startLog">Start Log</button>
            <button id="stopLog">Stop & Download CSV</button>
          </div>
          <div class="small">Log records: <span id="logCount">0</span></div>
        </div>
      </div>

    <script>
    // ---------- Simulator state ----------
    let state = { x:200, y:250, vx:0, vy:0, theta:0, omega:0 };
    let dt = 0.016; // physics step approx 60Hz
    let canvas = document.getElementById('c'), ctx = canvas.getContext('2d');
    let seaLevelY = 300; let seabedY = 770;
    let params = { mass: 800, volume: 0.9, area: 1.8, Cd: 0.8, rho: 1025, maxThrust: 3500, momentInertia: 400 };
    let controls = { throttle:0, steer:0, ballast:0 };
    let autopilot = { active: false, mode: 'off', targetDepth: 20, targetHeadingDeg: 0, targetSpeed: 3.0,
                      depth: { kp:0.8, ki:0.01, kd:0.3, integ:0, lastErr:0 },
                      heading:{ kp:1.5, ki:0.002, kd:0.2, integ:0, lastErr:0 },
                      speed:{ kp:0.6, ki:0.01, kd:0.05, integ:0, lastErr:0 } };
    let env = { currentSpeed: 0.5, currentDirRad: Math.PI/2, waveAmp: 6, waveFreq: 0.2 };
    let logging=false, logBuffer=[];
    // UI hooks (omitted for brevity) - full version in original project
    document.getElementById('th').oninput = e => { controls.throttle = parseFloat(e.target.value); document.getElementById('thVal').innerText = controls.throttle; };
    document.getElementById('st').oninput = e => { controls.steer = parseFloat(e.target.value); document.getElementById('stVal').innerText = controls.steer; };
    document.getElementById('ball').oninput = e => { controls.ballast = parseFloat(e.target.value); document.getElementById('ballVal').innerText = controls.ballast; };
    document.getElementById('reset').onclick = () => { state = {x:200,y:250,vx:0,vy:0,theta:0,omega:0}; autopilot.depth.integ=0; autopilot.heading.integ=0; autopilot.speed.integ=0; };
    document.getElementById('applyParams').onclick = () => {
      params.mass = Number(document.getElementById('mass').value);
      params.volume = Number(document.getElementById('volume').value);
      params.rho = Number(document.getElementById('rho').value);
      params.Cd = Number(document.getElementById('cd').value);
    };
    document.getElementById('mode').onchange = e => { autopilot.mode = e.target.value; };
    document.getElementById('engage').onclick = () => { autopilot.active = !autopilot.active; document.getElementById('engage').innerText = autopilot.active ? 'Disengage' : 'Engage'; };
    document.getElementById('targetDepth').oninput = e => { autopilot.targetDepth = Number(e.target.value); document.getElementById('targetDepthVal').innerText = autopilot.targetDepth; };
    document.getElementById('targetHeading').oninput = e => { autopilot.targetHeadingDeg = Number(e.target.value); document.getElementById('targetHeadingVal').innerText = autopilot.targetHeadingDeg; };
    document.getElementById('targetSpeed').oninput = e => { autopilot.targetSpeed = Number(e.target.value); document.getElementById('targetSpeedVal').innerText = autopilot.targetSpeed.toFixed(1); };
    document.getElementById('kp_d').onchange = e => { autopilot.depth.kp = Number(e.target.value); };
    document.getElementById('ki_d').onchange = e => { autopilot.depth.ki = Number(e.target.value); };
    document.getElementById('kd_d').onchange = e => { autopilot.depth.kd = Number(e.target.value); };
    document.getElementById('kp_h').onchange = e => { autopilot.heading.kp = Number(e.target.value); };
    document.getElementById('ki_h').onchange = e => { autopilot.heading.ki = Number(e.target.value); };
    document.getElementById('kd_h').onchange = e => { autopilot.heading.kd = Number(e.target.value); };
    document.getElementById('kp_s').onchange = e => { autopilot.speed.kp = Number(e.target.value); };
    document.getElementById('ki_s').onchange = e => { autopilot.speed.ki = Number(e.target.value); };
    document.getElementById('kd_s').onchange = e => { autopilot.speed.kd = Number(e.target.value); };
    document.getElementById('currSp').oninput = e => { env.currentSpeed = Number(e.target.value); document.getElementById('currSpVal').innerText = env.currentSpeed.toFixed(2); };
    document.getElementById('currDir').oninput = e => { document.getElementById('currDirVal').innerText = e.target.value; env.currentDirRad = Number(e.target.value) * Math.PI/180; };
    document.getElementById('waveAmp').oninput = e => { env.waveAmp = Number(e.target.value); document.getElementById('waveAmpVal').innerText = env.waveAmp; };
    document.getElementById('waveFreq').oninput = e => { env.waveFreq = Number(e.target.value); document.getElementById('waveFreqVal').innerText = env.waveFreq; };
    document.getElementById('startLog').onclick = () => { logging=true; logBuffer=[]; document.getElementById('logCount').innerText = 0; alert('Logging started'); };
    document.getElementById('stopLog').onclick = () => { logging=false; if(logBuffer.length===0){ alert('No logs'); } else { /* download logic omitted for brevity */ alert('Logs recorded (download logic available in full package)'); } };
    function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }
    function wrapAngleRad(a){ while(a>Math.PI) a -= 2*Math.PI; while(a<-Math.PI) a += 2*Math.PI; return a; }
    function spatialCurrent(x,y,t){
      let ux = env.currentSpeed * Math.cos(env.baseDirRad || Math.PI/2);
      let uy = env.currentSpeed * Math.sin(env.baseDirRad || Math.PI/2);
      let dx = x - (env.vortexCenter && env.vortexCenter.x || 640);
      let dy = y - (env.vortexCenter && env.vortexCenter.y || 360);
      let r = Math.hypot(dx, dy) + 0.0001;
      let R = env.vortexRadius || 300;
      let vortexStrength = (env.vortexStrength || 0.6) * Math.exp(- (r*r) / (R*R));
      let vx = -dy / r; let vy = dx / r;
      let mag = vortexStrength * (1.2 * (1 - Math.exp(-r/R)));
      mag *= (1 + 0.15 * Math.sin(t * 0.5));
      return [ ux + vx * mag, uy + vy * mag ];
    }
    function seaSurfaceY(x, t){
      let amp = env.waveAmp;
      let freq = env.waveFreq;
      let phase = 2*Math.PI*freq*t;
      let y1 = amp * Math.sin(0.006 * x - phase);
      let y2 = (amp*0.4) * Math.sin(0.014 * x - phase*1.4 + 1.2);
      return seaLevelY + y1 + y2;
    }
    function stepPhysics(dt, t){
      if(autopilot.active && autopilot.mode !== 'off'){
        let depthTargetPx = seaLevelY + clamp(autopilot.targetDepth, 0, 400);
        let surfaceY = seaSurfaceY(state.x, t);
        let depthPx = Math.max(0, state.y - surfaceY);
        if(autopilot.mode === 'depth' || autopilot.mode === 'both' || autopilot.mode === 'all'){
          let err = depthTargetPx - depthPx;
          let D = autopilot.depth; D.integ += err * dt; D.integ = clamp(D.integ, -1000, 1000);
          let deriv = (err - D.lastErr) / dt; let out = D.kp * err + D.ki * D.integ + D.kd * deriv; D.lastErr = err;
          controls.ballast = clamp(out * 0.0006, -1, 1);
          document.getElementById('ball').value = controls.ballast; document.getElementById('ballVal').innerText = controls.ballast.toFixed(3);
        }
        if(autopilot.mode === 'heading' || autopilot.mode === 'both' || autopilot.mode === 'all'){
          let targetRad = autopilot.targetHeadingDeg * Math.PI/180;
          let err = wrapAngleRad(targetRad - state.theta);
          let H = autopilot.heading; H.integ += err * dt; H.integ = clamp(H.integ, -10, 10);
          let deriv = (err - H.lastErr) / dt; let out = H.kp * err + H.ki * H.integ + H.kd * deriv; H.lastErr = err;
          controls.steer = clamp(out * 1.0, -1.2, 1.2);
          document.getElementById('st').value = controls.steer; document.getElementById('stVal').innerText = controls.steer.toFixed(3);
        }
        if(autopilot.mode === 'speed' || autopilot.mode === 'all'){
          let [cvx, cvy] = spatialCurrent(state.x, state.y, t);
          let relVx = state.vx - cvx; let relVy = state.vy - cvy;
          let forwardVel = relVx * Math.cos(state.theta) + relVy * Math.sin(state.theta);
          let desired = autopilot.targetSpeed; let err = desired - forwardVel;
          let S = autopilot.speed; S.integ += err * dt; S.integ = clamp(S.integ, -100, 100);
          let deriv = (err - S.lastErr) / dt; let out = S.kp * err + S.ki * S.integ + S.kd * deriv; S.lastErr = err;
          controls.throttle = clamp(out, -1, 1); document.getElementById('th').value = controls.throttle; document.getElementById('thVal').innerText = controls.throttle.toFixed(3);
        }
      }
      let [currVx, currVy] = spatialCurrent(state.x, state.y, t);
      let thrust = controls.throttle * params.maxThrust; let fx_th = Math.cos(state.theta) * thrust; let fy_th = Math.sin(state.theta) * thrust;
      let relVx = state.vx - currVx; let relVy = state.vy - currVy; let relSpeed = Math.hypot(relVx, relVy);
      let surfaceY = seaSurfaceY(state.x, t); let inWater = state.y > surfaceY;
      let rhoEnv = inWater ? params.rho : 1.225; let Cd = params.Cd; let A = params.area;
      let dragMag = 0.5 * rhoEnv * Cd * A * relSpeed * relSpeed;
      let fx_drag = relSpeed > 0.001 ? -dragMag * (relVx / relSpeed) : 0; let fy_drag = relSpeed > 0.001 ? -dragMag * (relVy / relSpeed) : 0;
      let submergedFraction = clamp((state.y - surfaceY) / 200, 0, 1); let Vsub = params.volume * submergedFraction;
      let Fbuoy = params.rho * Vsub * 9.81; let Fgrav = params.mass * 9.81; let ballastForce = controls.ballast * 12000;
      let fy_net = (Fbuoy - Fgrav) - ballastForce + fy_th + fy_drag; let fx_net = fx_th + fx_drag;
      let ax = fx_net / params.mass; let ay = fy_net / params.mass;
      let torque = controls.steer * controls.throttle * 1500; let alpha = torque / params.momentInertia;
      state.vx += ax * dt; state.vy += ay * dt; state.x += state.vx * dt; state.y += state.vy * dt; state.omega += alpha * dt; state.theta += state.omega * dt;
      let eps = 0.0001; let waveSlopeX = (seaSurfaceY(state.x + 5, t) - seaSurfaceY(state.x - 5, t)) / 10;
      let pitchTarget = clamp(-waveSlopeX * 0.5, -0.3, 0.3); state.pitch = state.pitch || 0; state.pitch += (pitchTarget - state.pitch) * 0.08;
      let lateralAcc = (-ax * Math.sin(state.theta) + ay * Math.cos(state.theta)); let rollTarget = clamp(lateralAcc / 9.81 * 0.15, -0.4, 0.4); state.roll = state.roll || 0; state.roll += (rollTarget - state.roll) * 0.08;
      if(state.y > seabedY){ state.y = seabedY; state.vy = -state.vy * 0.2; } if(state.y < 10){ state.y = 10; state.vy = 0; }
      state.omega *= 0.998;
    }
    function draw(t){
      ctx.clearRect(0,0,canvas.width,canvas.height);
      let g = ctx.createLinearGradient(0,0,0,canvas.height); g.addColorStop(0,"#79c1ff"); g.addColorStop(1,"#a6e0ff"); ctx.fillStyle = g; ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.beginPath(); ctx.moveTo(0, seaSurfaceY(0, t/1000)); for(let x=1;x<=canvas.width;x+=3){ ctx.lineTo(x, seaSurfaceY(x, t/1000)); } ctx.lineTo(canvas.width, canvas.height); ctx.lineTo(0, canvas.height); ctx.closePath(); ctx.fillStyle = "#0e77b7"; ctx.fill();
      ctx.fillStyle="#6b5038"; ctx.fillRect(0, seabedY, canvas.width, canvas.height - seabedY);
      ctx.save(); ctx.globalAlpha = 0.85; for(let gx=50; gx<canvas.width; gx+=120){ for(let gy=50; gy<canvas.height-100; gy+=120){ let [cvx, cvy] = spatialCurrent(gx, gy, performance.now()/1000); let len = Math.hypot(cvx, cvy); let scale = 12; ctx.beginPath(); ctx.strokeStyle = (len>0.8 ? '#ffeb3b' : '#ffffff'); ctx.lineWidth = 2; ctx.moveTo(gx, gy); ctx.lineTo(gx + cvx*scale, gy + cvy*scale); ctx.stroke(); let ang = Math.atan2(cvy, cvx); ctx.beginPath(); ctx.moveTo(gx + cvx*scale, gy + cvy*scale); ctx.lineTo(gx + cvx*scale - 6*Math.cos(ang-0.4), gy + cvy*scale - 6*Math.sin(ang-0.4)); ctx.lineTo(gx + cvx*scale - 6*Math.cos(ang+0.4), gy + cvy*scale - 6*Math.sin(ang+0.4)); ctx.closePath(); ctx.fillStyle = (len>0.8 ? '#ffeb3b' : '#ffffff'); ctx.fill(); } } ctx.restore();
      ctx.save(); ctx.translate(state.x, state.y); ctx.rotate(state.theta); ctx.save(); ctx.rotate(state.roll * 0.4); ctx.transform(1, 0, Math.tan(-state.pitch*0.2), 1, 0, 0); ctx.fillStyle = (state.y > seaSurfaceY(state.x, performance.now()/1000)) ? "#00ffcc" : "#ffcc00"; ctx.beginPath(); ctx.moveTo(36,0); ctx.lineTo(-24,18); ctx.lineTo(-24,-18); ctx.closePath(); ctx.fill(); ctx.restore(); ctx.fillStyle = "rgba(0,0,0,0.6)"; ctx.beginPath(); ctx.arc(10,0,6,0,Math.PI*2); ctx.fill(); ctx.restore();
      ctx.fillStyle = "#fff"; ctx.font = "13px monospace"; ctx.fillText("X:"+state.x.toFixed(1)+" Y:"+state.y.toFixed(1)+" vx:"+state.vx.toFixed(2)+" vy:"+state.vy.toFixed(2), 10, 20); ctx.fillText("theta:"+ (state.theta*180/Math.PI).toFixed(1) +"°  pitch:"+ (state.pitch*180/Math.PI).toFixed(1)+"° roll:"+ (state.roll*180/Math.PI).toFixed(1)+"°", 10, 38); ctx.fillText("Mode:"+autopilot.mode+"  Autopilot:"+ (autopilot.active? "ON":"OFF"), 10, 56);
    }
    function updateTelemetry(timeNow){
      let surfaceY = seaSurfaceY(state.x, timeNow); let inWater = state.y > surfaceY; let depthMeters = inWater ? (state.y - surfaceY) : 0; let speed = Math.hypot(state.vx, state.vy); let [cvx, cvy] = spatialCurrent(state.x, state.y, timeNow); let forwardVel = (state.vx - cvx) * Math.cos(state.theta) + (state.vy - cvy) * Math.sin(state.theta); let headingDeg = (state.theta * 180/Math.PI); if(headingDeg > 180) headingDeg -= 360; let tele = `depth_m: ${depthMeters.toFixed(2)}\\nspeed_mps: ${speed.toFixed(2)}\\nforward_mps: ${forwardVel.toFixed(2)}\\nheading_deg: ${headingDeg.toFixed(1)}°\\nthrottle: ${controls.throttle.toFixed(3)}\\nsteer: ${controls.steer.toFixed(3)}\\nballast: ${controls.ballast.toFixed(3)}\\nCurrV: ${cvx.toFixed(2)},${cvy.toFixed(2)} m/s\\nWave A:${env.waveAmp} F:${env.waveFreq}`; document.getElementById('tele').textContent = tele;
      if(logging){ let row = { t: timeNow.toFixed(3), x: state.x.toFixed(3), y: state.y.toFixed(3), vx: state.vx.toFixed(4), vy: state.vy.toFixed(4), theta: state.theta.toFixed(5), pitch: state.pitch.toFixed(4), roll: state.roll.toFixed(4), depth_m: depthMeters.toFixed(3), speed: speed.toFixed(4), forward_mps: forwardVel.toFixed(4), throttle: controls.throttle.toFixed(3), steer: controls.steer.toFixed(3), ballast: controls.ballast.toFixed(3), mode: autopilot.mode, autopilot_on: autopilot.active ? 1 : 0 }; logBuffer.push(row); document.getElementById('logCount').innerText = logBuffer.length; } }
    function downloadCSV(){ if(logBuffer.length === 0){ alert('No logs to download'); return; } let keys = Object.keys(logBuffer[0]); let csv = keys.join(',') + '\\n'; for(let r of logBuffer){ csv += keys.map(k => (''+r[k]).replace(/,/g,'')).join(',') + '\\n'; } let blob = new Blob([csv], { type: 'text/csv' }); let url = URL.createObjectURL(blob); let a = document.createElement('a'); a.href = url; a.download = 'hybrid_env_log_' + (new Date()).toISOString().replace(/[:.]/g,'-') + '.csv'; a.click(); URL.revokeObjectURL(url); }
    let last = performance.now();
    function loop(now){ let dtReal = Math.min(0.04, (now-last)/1000); last = now; let steps = Math.ceil(dtReal / dt); for(let i=0;i<steps;i++) stepPhysics(dt/1.0, (now - (steps-i-1)*dt*1000)/1000.0); draw(now); updateTelemetry(now/1000.0); requestAnimationFrame(loop); }
    requestAnimationFrame(loop);
    </script>
    </body>
    </html>
